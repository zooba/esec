# Evolutionary System Description Language

## Introduction

ESDL is a conceptual model and language for describing evolutionary systems efficiently and unambiguously. esec uses ESDL for its system definitions, allowing rapid modification and testing of different algorithms.

A detailed technical report describing ESDL has been published at [stevedower.id.au](http://stevedower.id.au/) ([PDF](http://stevedower.id.au/papers/evolutionary_system_definition_language_2010.pdf)). This page provides a more pragmatic overview of the syntax and use of ESDL.

## Concept

The concept underlying ESDL is that evolutionary systems are searching for the best solution to a problem from a very large collection of potential solutions. In simple systems, each potential solution is an _individual_ (in complex systems, a potential solution may be made up of multiple individuals).

Since the collection of possible solutions is too large to enumerate, relatively small subsets of individuals, _groups_, are used instead. In most examples of evolutionary systems, the main group is called the _population_. Since the population is small, every individual can be tested to determine its _fitness_ for solving the given problem. When a good enough fitness (not necessarily an ideal fitness) is found, the problem is solved.

It is very unlikely that the initial population will contain a good enough enough, and so a new population needs to be created. Unlike the first time, however, there is some extra information available: some individuals in the current population are better (more fit) than others, and this knowledge can be used to bias the generation of the next population. Exactly how is a matter of much research, debate and experimentation and there is generally accepted to be no "right" answer for every situation. However, there are some very common approaches.

Most new populations are generated by somehow modifying the previous generation. The potential range of modification operations is well beyond the scope of this article, except for the general approach that an operator takes one or more current individuals and produces one or more very slightly modified individuals. By only making small modifications it is possible to assume causation between the change and any resulting change to the fitness. If the fitness improves, the change is assumed to be helpful and it is retained in the population. Conversely, if the fitness reduces, the change that was made was not helpful and it is forgotten. This feedback process is implied by the selection methods used, which are usually based on fitness. Note, however, that _always_ preferring the individual with better fitness is very greedy and not necessarily ideal for any particular problem.

ESDL defines the links between the groups, including specifying which operator is used. Since dealing with individuals on a one-by-one basis is cumbersome, operators are applied to all the individuals in a certain group, producing a new group. Because ESDL uses a general concept of "groups" rather than a specific "population-parents-offspring" structure, much more complicated systems can be expressed. For example, "multi-population" systems are nothing special, since each population is just another group.

## Syntax
This syntax specification uses a grammar syntax similar to EBNF with lowercase names referring to other rules, uppercase names referring to terminals that are defined separately from the grammar and quoted strings referring to literal text. This is not intended to represent a complete grammar for ESDL but is simply making use of a familiar notation.

### From-Select
The `FROM-SELECT` statement creates groups of individuals from other groups, optionally using a filter.

#### Specification

```
select_statement: "FROM" source_list "SELECT" destination_list [ "USING" filter_list ]

source_list: GROUP [ "," source_list ]
           | initialiser [ "," source_list ]

initialiser: INITIALISER [ "()" ]
           | INITIALISER "(" parameter_list ")"

destination_list: [ SIZE ] GROUP [ "," destination_list ]

filter_list: filter [ "," filter_list ]

filter: GENERATOR [ "()" ]
      | GENERATOR "(" parameter_list ")"

parameter_list: NAME "=" VALUE [ "," parameter_list ]
```

Source groups are combined to produce a single group of all individuals (including duplicates) in all of the source groups. An initialiser is an externally defined generator that produces an unbounded set of individuals. All initialiser parameters are name-value pairs; names must be specified and are case-sensitive. Parameters may have default values, in which case they may be omitted.

Generators are externally defined functions or classes that accept a sequence of individuals and produce a new sequence. The first generator is passed the result of combining all source groups, retaining duplicates. When multiple generators are specified, the output of each is passed as the input to the next, in the order specified. All generator parameters are name-value pairs; names must be specified and are case-sensitive. Parameters may have default values, in which case they may be omitted.

Destination groups are assigned individuals from the output of the generator(s). If a size value is specified for a group, that number of individuals will be assigned to that group. If a size value is not specified, the group is considered unbounded and is assigned all the individuals available. Only the last specified group may be specified as unbounded. Specifying an unbounded generator or initialiser with an unbounded destination group is an error.

If a destination group already exists, its contents is completely replaced by the new individuals.

#### Examples
**Example 1**
```
FROM population SELECT 10 parents USING binary_tournament
```
Creates a group of 10 individuals named `parents` using individuals from `population`.

**Example 2**
```
FROM offspring, elitist SELECT population
```
Creates a group `population` containing all individuals from `offspring` and `elitist`.

**Example 3**
```
FROM population SELECT 10 parents, remainder USING uniform_shuffle
```
Creates a group `parents` containing ten random individuals from `population` and a group `remainder` that contains every other individual from `population`.

**Example 4**
```
FROM parents SELECT offspring USING crossover_one, mutate_random
```
Creates a group `offspring` containing the individuals from `parents` after performing single-point crossover and random mutation.

**Example 5**
```
FROM random_real(lowest=0.0,highest=10.0,length=12) SELECT 100 population
```
Creates a group of 100 random real-valued individuals, each consisting of 12 genes with values between 0.0 and 10.0.

**Example 6**
```
FROM random_int(lowest=0,highest=10,shortest=5,longest=50) SELECT 50 population USING valid_only
```
Creates a group of 50 valid random variable-length integer individuals. 

### Join-Into
The `JOIN-INTO` statement creates groups of joined (sub-grouped) individuals from other groups, where each individual in the new group is made up of individuals from the source groups.

#### Specification

```
join_statement: "JOIN" source_list "INTO" GROUP "USING" joiner

source_list: GROUP [ "," source_list ]
           | initialiser [ "," source_list ]

initialiser: INITIALISER [ "()" ]
           | INITIALISER "(" parameter_list ")"

joiner: JOINER [ "()" ]
      | JOINER "(" parameter_list ")"

parameter_list: NAME "=" VALUE [ "," parameter_list ]
```

Joiners are externally defined functions or classes that accept a list of sequences of individuals and produce one new sequence of individuals. All joiner parameters are name-value pairs; names must be specified and are case-sensitive. Parameters may have default values, in which case they may be omitted.

The destination group is assigned all individuals from the output of the joiner. If a destination group already exists, its contents is completely replaced by the new individuals.

#### Examples
**Example 1**
```
JOIN group_a, group_b INTO matched USING full_combine
```
Joins every individual from `group_a` with every individual from `group_b` into the group `matched`.

**Example 2**
```
JOIN programs, parameters INTO executables USING make_executables
EVAL executables USING program_runner
EVAL parameters USING credit_assignment(executables)
```
Uses a custom combiner to produce combinations of `programs` and `parameters`, then uses the `credit_assignment` evaluator for parameters to update their fitnesses. The evaluator `program_runner` is used for the combined individuals in `executables`. (No evaluator has been specified for `programs`.)

### Evaluate
The `EVALUATE` or `EVAL` statement specifies the evaluator to use to determine the fitness of individuals. `EVAL` is applied to a group, but it associates each individual in that group with the specified evaluator.

#### Specification
```
eval_statement: "EVAL" GROUP [ "USING" evaluator ]
              | "EVALUATE" GROUP [ "USING" evaluator ]

evaluator: EVALUATOR [ "()" ]
         | EVALUATOR "(" parameter_list ")"

parameter_list: NAME "=" VALUE [ "," parameter_list ]
```

Evaluators are externally defined functions that accept a single individual and return the fitness value for that individual. Each individual is associated with one evaluator. If the evaluator is omitted from the `EVAL` statement, the individuals in the group are associated with their default evaluator, if any. All evaluator parameters are name-value pairs; names must be specified and are case-sensitive. Parameters may have default values, in which case they may be omitted.

Whenever individuals are assigned a new or modified evaluator, a new fitness evaluation must occur. If individuals are assigned an identical evaluator, they may retain their previous fitness.

#### Examples
**Example 1**
```
EVAL offspring USING approximate_eval
```
Evaluates every member of the `offspring` group using `approximate_eval`.

**Example 2**
```
EVAL offspring
```
Evaluates every member of the `offspring` group using the default evaluator.

### Yield
The `YIELD` statement passes the specified group or groups to a monitoring system, which may perform tasks such as collecting statistics, updating a user interface or determining whether to continue the experiment.

#### Specification

```
yield_statement: "YIELD" group_list

group_list: GROUP [ "," group_list ]
```

The external monitoring system is specified separately from the ESDL system definition. The monitoring system is provided with the name and contents of the group in a form that is guaranteed to not change prior to the monitor returning control to the system (for example, by returning from the callback function). If multiple groups are provided, they may be passed to the monitor either in a single message or in separate messages.

#### Examples
**Example 1**
```
YIELD population
```
Passes the `population` group to the monitor.

**Example 2**
```
YIELD programs, parameters
```
Passes multiple groups to the monitor.

### Begin-End
The `BEGIN` and `END` statements start and finish blocks. Each iteration, one block is executed, based on the result of a selector function/list. Code appearing before the first block definition is considered to be initialisation code. Blocks may not be nested.

#### Specification
```
begin_statement: "BEGIN" NAME

end_statement: "END" [ NAME ]
```

The block name is not case-sensitive. The `END` statement is assumed to apply to the matching `BEGIN` and any text following `END` is ignored. (For readability, it is recommended to include the block name again.)

If multiple blocks are specified, they will each execute once in turn unless a selector is specified. Some examples of selectors are provided below.

### Repeat-End
The `REPEAT` statement starts a repeated block. A repeated block is terminated by an `END` statement.

#### Specification
```
repeat_statement: "REPEAT" VALUE

end_statement: "END" [ "REPEAT" ]
```

The block is executed the number of times represented by `VALUE` upon entry to the repeated block (that is, changes to `VALUE` within the repeated block do not affect the number of repetitions).

The `END` statement is assumed to apply to the matching `REPEAT` and any text following `END` is ignored. (For readability, it is recommended to include `REPEAT` again.)

### Variables and Arithmetic
ESDL supports at least the following operations relating to variables:

  * Implicit variable allocation
  * Strong and dynamic variable typing (the type is associated with the value, not the variable)
  * Floating-point addition, subtraction, multiplication, division
   * Integer values are converted to real values either immediately or when necessary
  * Group aliasing (by normal assignment)
  * Calls to external functions with positional and named parameters
   * Includes assigning returned values to variables

Notably, control-flow statements are omitted. Complex behaviours should be abstracted into external functions.

### Comments
Lines containing a hash character (`#`), a semi-colon (`;`) or a double forward-slash (`//`) should be ignored from the first unquoted instance of the character until the following line break.

### Line Continuation
Line break characters within brackets (`[]`), parentheses (`()`), braces (`{}`) or quotes (`'` or `"`) or immediately following a backslash character (`\`) should be ignored.

If a backslash character is followed by a comment, the comment and the line break are ignored.

### Backticked Lines
Lines beginning with a backtick character (grave accent, {{{`}}}) are treated in an implementation-specific manner. They may be interpreted as compiler pragmas, hints or extended syntax as desired.

System definitions that include backticked lines should specify which implementation of ESDL (for example, esec version 1.0) is required.

## System Examples

### Genetic Algorithms with single-point crossover and mutation

Creates a population of 100 binary-valued individuals. Each generation, 100 breeders are selected  (with replacement) in proportion to their fitness and then combined and mutated to form the new population.

```
FROM random_binary SELECT 100 population
YIELD population

BEGIN GENERATION
  FROM population SELECT 100 parents USING fitness_proportional(replacement=True)
  FROM parents    SELECT population  USING crossover_one, mutate_random(per_gene_rate=0.1)
  YIELD population
END GENERATION
```

### Genetic Algorithms with crossover, mutation and elitism

Creates a population of 500 binary-valued individuals. Each generation, all but the best individual (the 'elitist') are replaced. Of the 500 offspring, the worst is discarded. The elitist is permitted to participate in regular breeding.

```
FROM random_binary SELECT 500 population
YIELD population

BEGIN GENERATION
  FROM population SELECT 1 elitist   USING best
  FROM population SELECT 500 parents USING binary_tournament
  FROM parents    SELECT offspring   USING crossover_one, mutate_random(per_gene_rate=0.1)
  
  FROM parents, elitist SELECT 500 population USING best
  YIELD population
END GENERATION
```

### SSGA with 2 offspring

Creates a population of 250 real-valued individuals with 10 genes each (range `[-1.0, 1.0)`). Two parents are selected, crossed and mutated to make two offspring. The better of the offspring replaces a random individual in the population _if_ it is better than the replacee. A 'generation' occurs every 250 replacements. The two offspring and the replacee are yielded every step and the entire population is yielded once per generation-equivalent.

```
FROM random_real(lowest=-1.0, highest=1.0, length=10) SELECT 250 population
YIELD population

BEGIN GENERATION
  REPEAT 250
    FROM population SELECT 2 parents USING binary_tournament
    FROM parents    SELECT offspring USING recombine_one_point, mutate_random(0.2)
    FROM population SELECT 1 replacee, remainder USING uniform_random
    YIELD offspring, replacee
    
    FROM offspring, replacee SELECT 1 offspring USING best
    FROM remainder, offspring SELECT population
  END REPEAT
  
  YIELD population
END GENERATION
```

### Genetic Algorithms with adaptive mutation rate
Population of 100. `diversity` is a theoretical function* that calculates the diversity of the group passed to it and returns a value `[0.0, 1.0]`, which is used to adjust the rate of mutation.

```
FROM random_int SELECT 100 population

BEGIN GENERATION
  mutate_rate = 1 - diversity(population)
  FROM population SELECT 100 parents USING fitness_proportional
  FROM parents    SELECT offspring   USING crossover_one, mutate_random(per_gene_rate=mutate_rate)
  FROM offspring  SELECT population
  YIELD population
END GENERATION
```

{*} Theoretical in the sense that esec does not provide such a diversity function, nor is one defined for this example.

### Evolution Strategies
A single individual is selected randomly from a population of 10 and mutated 10 times. The best 10 individuals from the original population and the mutated offspring are retained. The `es_success_rate` method calculates the percentage of individuals whose fitness improved with mutation, and `es_adapt` applies the 1/5th adaptive mutation rule to either increase or decrease the mutation rate. 

```
FROM suitable_individuals SELECT 10 population
YIELD population

current_step = 1.0
adapt_step = 0.1

BEGIN GENERATION
    FROM population SELECT 1 parent   USING uniform_random
    FROM parent     SELECT 10 parents USING repeat
    FROM parents    SELECT offspring  USING mutate_gaussian(step_size=current_step)
    YIELD offspring

    # calculate success rate based on parents and offspring
    success_rate = es_success_rate(parents, offspring)
    current_step = es_adapt(current_step, adapt_step, success_rate)
    
    FROM population, offspring SELECT 10 population USING best
    YIELD population
END GENERATION
```

The `es_success_rate` and `es_adapt` functions are defined externally, in this case, using Python.

```
def es_success_rate(parents, offspring):
    # Return the percentage of offspring who are more fit than their parent.
    count = 0
    for p,o in zip(parents, offspring):
        if o.fitness > p.fitness: count += 1
    return float(count) / float(len(parents))

def es_adapt(current_step, adapt_step, success_rate):
    # Use the 1/5th adaptive mutation rule to return the new step size.
    if success_rate > 0.21:
        return current_step * (1.0 + adapt_step)
    elif success_rate < 0.19:
        return current_step * (1.0 - adapt_step)
    else:
        return current_step
```


### Differential Evolution

[Differential Evolution](http://www.icsi.berkeley.edu/~storn/code.html) (DE) is an efficient algorithm for real-valued optimisation problems (follow the link for a full explanation of how it works).

```
FROM random_real SELECT 100 population
YIELD population

BEGIN GENERATION
    # SELECT without a USING makes a copy of the group
    FROM population SELECT 100 targets
    
    # targets is only included to ensure the three mutation vectors are different ones.
    JOIN targets, population, population, population INTO mutators USING random_tuples(distinct=True)
    
    # mutate_DE is defined below
    FROM mutators SELECT mutants USING mutate_DE(scale=0.1)
    
    JOIN targets, mutants INTO target_mutant_pairs USING tuples
    FROM target_mutant_pairs SELECT trials USING crossover_tuple(per_gene_rate=0.5)
    
    JOIN targets, trials INTO targets_trial_pairs USING tuples
    FROM targets_trial_pairs SELECT population USING best_of_tuple
    
    YIELD population
END GENERATION
```

The `mutate_DE` operator appearing above is provided externally. In this case, it is written in Python using the classes provided by esec.

```
def mutate_DE(source, scale):
    '''A generator that yields one mutated Individual for every JoinedIndividual
    passed in source.
    '''
    for joined_individual in source:
        target, base, parameter1, parameter2 = joined_individual[:]
        yield RealIndividual([b + scale * (p1 - p2) for b, p1, p2 in zip(base, parameter1, parameter2)])
```

### Multiple Blocks

As a demonstration of multiple named blocks, the following system separates the mutation process (`mutate_block`) from the recombination process (`crossover_block`), with different selection in each.

```
FROM random_real SELECT (size) population
YIELD population

BEGIN mutate_block
    FROM population SELECT (size) parents USING binary_tournament
    FROM parents SELECT offspring USING mutate_gaussian
    FROM population, offspring SELECT (size) population USING best
    
    YIELD population
END

BEGIN crossover_block
    FROM population SELECT (size/2) parents1 USING best
    FROM population SELECT (size/2) parents2 USING uniform_random
    FROM parents1, parents2 SELECT parents USING uniform_shuffle
    FROM parents SELECT population USING crossover_uniform
    
    YIELD population
END
```

By default, `mutate_block` will execute once, followed by `crossover_block` once, then `mutate_block` and so on. To specify an alternate order, the `selector` parameter of the experiment configuration must be specified:

```
config = {
    'system': { 'definition': SYSTEM_DEFINITION },
    'selector': [ 'mutate_block', 'mutate_block', 'crossover_block' ]
```
```

With this list-based selector, `mutate_block` is executed twice before `crossover_block` is executed once. Any iterable type may be provided as a selector:

```
from esec.context import rand, context
def RandomSelector():
    while True:
        yield 'mutate_block' if rand.random() < 0.5 else 'crossover_block'

config['selector'] = RandomSelector()
```

This selector returns the name of either block randomly with equal probability. More complex selectors may be implemented by defining a class with `__iter__` and `next` methods (or `__next__` in Python 3), and by importing `context` from `esec.context` (as in the example below), global variables within the definition may be accessed.


```
from esec.context import context
from oldhouse.wardrobe import measure_group_diversity

class MutateWhenSimilar(object):
    def __init__(self, group_name):
        self.group_name = group_name
    
    def __iter__(self):
        return self
    
    def next(self):
        if measure_group_diversity(context[self.group_name]) < 0.5:
            yield 'mutate_block'
        else:
            yield 'crossover_block'

config['selector'] = MutateWhenSimilar('population')
```
